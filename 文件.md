##  文件

文件：

1.**磁盘文件**

2.**设备文件**：在操作系统中把每一个与主机相连的输入，输出设备看作是一个文件，把它们的输入，输出等同于对磁盘文件的读和写。

键盘：标准输入文件

屏幕：标准输出文件

其他设备：打印机，触摸屏，摄像头，音箱等等。



在Linux系统中，每一个外部设备都在`/dev`目录下对应着一个**设备文件**，咱们再程序中要想操作设备，就必须对与其对应的`/dev`下的设备文件进行操作。

**标准io库函数对磁盘文件的读取特点：**

![](images\image-20201029163728200.png)

文件缓冲区是库函数申请的一段内存，由库函数对其进行操作，程序员无需知道存放在哪里，只需要对文件操作的时候的一些缓冲特点即可。

### 各种缓冲区分类

#### 行缓冲

==**标准io库函数，往标准输出**==（屏幕）输出东西的时候是行缓冲的

所谓的行缓冲就是缓冲区碰到换行符的时候才刷新缓冲区



如果不刷新缓冲区，无法对文件执行读写操作。



行缓冲的四种**刷新方式 **：

```c
int main(){
	printf("hello");
    while(1){
        
    }
    return 0;
}// 终端还是打印出了 hello
```

```c
// 方式1：使用换行符\n
printf("hello world\n");

// 方式2：程序正常结束
printf("hello world");
return 0;

// 方式3：使用fflush函数刷新缓冲区
printf("hello world");
fflush(stdout); // fflush：刷新函数，可以刷新指定的缓冲区

// 方式4：当缓冲区满的时候自动刷新
// 默认行缓冲的大小为1024个字节
for(int i=0;i<100;++i){
    printf("%03d ",i);
}
/

// 没什么用，自动刷新
    需要在linux系统验证
```

#### 全缓冲

标准io库函数，往普通文件读写数据的，是全缓冲的，

碰到换行符也不刷新缓冲区，即缓冲区满了，才刷新缓冲区。

- 刷新缓冲区的情况：
  - 缓冲区满了，刷新
  - 认为刷新缓冲区，fflush(文件指针)
  - 程序正常结束，会刷新缓冲区

#### 无缓冲

在读写文件的时候通过**系统调用io**(read write)，对文件进行读写数据。

这个时候是无缓冲的，即写数据会立马读写文件，读数据会立马进入内存。

------

 ### 写文件的流程

应用程序空间->内核空间->驱动程序->硬盘上

应用程序和内核程序运行在不同的空间里，目的是为了保护内核。

### 设置缓冲区的目的

通过缓冲可以**减少进出内核的次数，以提高效率**。

------

## 磁盘文件的分类

计算机的存储在物理上是二进制的，所以物理上所以的磁盘文件本质上都是一样的：**以字节为单位进行顺序存储**。

从用户或者操作系统使用的角度 把文件分为：

​	**文本文件**：基于**字符编码**的文件

​	**二进制文件**：基于**值编码**的文件

#### 文本文件

基于字符编码，常见编码有 ASCII，UNICODE等

一般可以使用文本编辑器直接打开

例如：数5678的以ASCII存储形式为：

​	ASCII码：00110101 00110110 00110111 00111000

​    歌词文件)(lrc)：文本文件

#### 二进制文件

基于值编码，把内存中的数据按其在内存中的存储形式原样输出到磁盘上



音频文件(mp3)：二进制文件

图片文件（bmp）：一个像素点由两个字节来描述`*****#####&&&&&`

*代表红色的值，#代表绿色的值，&代表蓝色的值。

#### 文本文件，二进制文件对比

**译码**：

​	文本文件编码基于字符定长，译码容易些；

​	二进制文件编码是变长的，译码难一些（不同的二进制文件格式，有不同的译码方式）

**空间利用率**：

​	二进制文件用一个比特来代表一个意思（位操作）；

​	而文本文件任何一个意思至少是一个字符。

二进制文件空间利用率高。

**可读性**：

​	文本文件使用通用的记事本工具就几乎可以浏览所有文本文件

​	二进制文件需要一个具体的文件解码器，比如读BMP文件，必须用读图软件。